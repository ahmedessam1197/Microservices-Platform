"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateCommand = generateCommand;
const fs_1 = require("fs");
const path_1 = require("path");
const glob_1 = require("glob");
const protobuf = __importStar(require("protobufjs"));
const utils_1 = require("../utils");
const logger_1 = require("../utils/logger");
const logger = new logger_1.GrpcLogger({
    context: 'GenerateCommand',
    level: 'log',
});
function validateOptions(options) {
    logger.debug(`Validating command options: proto=${options.proto}, output=${options.output}`);
    if (!options.proto || typeof options.proto !== 'string') {
        throw new Error('Proto path is required and must be a string');
    }
    if (!options.output || typeof options.output !== 'string') {
        throw new Error('Output path is required and must be a string');
    }
    if (!options.proto.includes('*') && !(0, fs_1.existsSync)(options.proto)) {
        throw new Error(`Proto path does not exist: ${options.proto}`);
    }
    try {
        const outputDir = (0, path_1.resolve)(options.output);
        const parentDir = (0, path_1.dirname)(outputDir);
        if ((0, fs_1.existsSync)(parentDir)) {
            (0, fs_1.accessSync)(parentDir, fs_1.constants.W_OK);
        }
    }
    catch {
        throw new Error(`Cannot write to output directory: ${options.output}`);
    }
    logger.debug('Command options validation completed');
}
function normalizeProtoPath(protoPath, silent) {
    try {
        if (!(0, fs_1.existsSync)(protoPath)) {
            return protoPath;
        }
        const stats = (0, fs_1.statSync)(protoPath);
        if (!stats.isFile() && !stats.isDirectory()) {
            throw new Error(`Proto path must be a file or directory: ${protoPath}`);
        }
        const isDirectory = stats.isDirectory();
        if (isDirectory && !protoPath.endsWith('/**/*.proto')) {
            const normalizedPath = protoPath.endsWith('/') ? protoPath : `${protoPath}/`;
            const result = `${normalizedPath}**/*.proto`;
            if (!silent) {
                logger.lifecycle('Directory detected, using pattern', { pattern: result });
            }
            return result;
        }
        return protoPath;
    }
    catch (error) {
        throw new Error(`Error accessing proto path: ${error.message}`);
    }
}
function findProtoFiles(pattern) {
    try {
        logger.debug(`Finding proto files with pattern: ${pattern}`);
        const files = (0, glob_1.globSync)(pattern, {
            ignore: ['node_modules/**', '**/node_modules/**'],
            absolute: true,
            nodir: true,
        });
        logger.debug(`Found ${files.length} proto files`);
        const validFiles = files.filter(file => {
            try {
                (0, fs_1.accessSync)(file, fs_1.constants.R_OK);
                return true;
            }
            catch {
                logger.warn(`Warning: Cannot read proto file: ${file}`);
                return false;
            }
        });
        logger.debug(`Valid proto files: ${validFiles.length}/${files.length}`);
        return validFiles;
    }
    catch (error) {
        throw new Error(`Error finding proto files: ${error.message}`);
    }
}
function createTypeOptions(options) {
    return {
        useClasses: Boolean(options.classes),
        includeComments: options.comments !== false,
        packageFilter: options.packageFilter ?? undefined,
        includeClientInterfaces: !options.noClientInterfaces,
    };
}
function ensureOutputDirectory(outputPath, silent) {
    try {
        const outputDir = (0, path_1.dirname)(outputPath);
        if (!(0, fs_1.existsSync)(outputDir)) {
            if (!silent) {
                logger.lifecycle('Creating directory', { path: outputDir });
            }
            (0, fs_1.mkdirSync)(outputDir, { recursive: true });
        }
        (0, fs_1.accessSync)(outputDir, fs_1.constants.W_OK);
    }
    catch (error) {
        throw new Error(`Failed to create output directory: ${error.message}`);
    }
}
async function loadProtoFile(protoFile) {
    try {
        logger.debug(`Loading proto file: ${protoFile}`);
        (0, fs_1.accessSync)(protoFile, fs_1.constants.R_OK);
        const root = await protobuf.load(protoFile);
        if (!root) {
            throw new Error('Proto file loaded but returned null');
        }
        logger.debug(`Successfully loaded proto file: ${protoFile}`);
        return root;
    }
    catch (error) {
        if (error.message.includes('ENOENT')) {
            throw new Error(`Proto file not found: ${protoFile}`);
        }
        throw new Error(`Failed to load proto file ${protoFile}: ${error.message}`);
    }
}
function writeTypesToFile(content, outputPath) {
    if (!content || typeof content !== 'string') {
        throw new Error('Invalid content to write');
    }
    try {
        logger.debug(`Writing types to file: ${outputPath}`);
        ensureOutputDirectory(outputPath, true);
        (0, fs_1.writeFileSync)(outputPath, content, 'utf8');
        if (!(0, fs_1.existsSync)(outputPath)) {
            throw new Error('File was not created successfully');
        }
        logger.debug(`Successfully wrote types to file: ${outputPath}`);
    }
    catch (error) {
        throw new Error(`Failed to write types to ${outputPath}: ${error.message}`);
    }
}
function getOutputPath(protoFile, outputDir) {
    try {
        const baseName = (0, path_1.basename)(protoFile, '.proto');
        if (!baseName) {
            throw new Error(`Invalid proto file name: ${protoFile}`);
        }
        return (0, path_1.join)(outputDir, `${baseName}.ts`);
    }
    catch (error) {
        throw new Error(`Failed to determine output path: ${error.message}`);
    }
}
async function generateTypesForFile(protoFile, outputDir, typeOptions, silent) {
    try {
        if (!silent) {
            logger.lifecycle('Processing proto file', { file: protoFile });
        }
        const outputFile = getOutputPath(protoFile, outputDir);
        const root = await loadProtoFile(protoFile);
        const typeDefinitions = (0, utils_1.generateTypeDefinitions)(root, typeOptions);
        if (!typeDefinitions || typeDefinitions.trim().length === 0) {
            logger.warn(`Warning: No type definitions generated for ${protoFile}`);
            return;
        }
        writeTypesToFile(typeDefinitions, outputFile);
        if (!silent) {
            logger.lifecycle('Generated types successfully', {
                input: protoFile,
                output: outputFile,
            });
        }
    }
    catch (error) {
        logger.error(`Error processing ${protoFile}`, error);
        throw error;
    }
}
async function generateCommand(options) {
    try {
        validateOptions(options);
        const normalizedProtoPath = normalizeProtoPath(options.proto, Boolean(options.silent));
        const protoFiles = findProtoFiles(normalizedProtoPath);
        if (protoFiles.length === 0) {
            console.error(`No proto files found matching pattern: ${normalizedProtoPath}`);
            return 1;
        }
        if (!options.silent) {
            logger.lifecycle('Found proto files', { count: protoFiles.length });
        }
        const typeOptions = createTypeOptions(options);
        ensureOutputDirectory(options.output, Boolean(options.silent));
        let processedCount = 0;
        let errorCount = 0;
        for (const protoFile of protoFiles) {
            try {
                await generateTypesForFile(protoFile, options.output, typeOptions, Boolean(options.silent));
                processedCount++;
            }
            catch {
                errorCount++;
            }
        }
        if (!options.silent) {
            logger.lifecycle('Processing complete', {
                succeeded: processedCount,
                failed: errorCount,
            });
        }
        if (processedCount === 0) {
            console.error('No files were processed successfully');
            return 1;
        }
        if (errorCount > 0 && !options.silent) {
            logger.warn(`Warning: ${errorCount} files failed to process`);
        }
        return 0;
    }
    catch (error) {
        console.error(error.message);
        return 1;
    }
}
//# sourceMappingURL=generate.command.js.map