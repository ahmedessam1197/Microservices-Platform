"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcProtoService = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const common_1 = require("@nestjs/common");
const glob_1 = require("glob");
const constants_1 = require("../constants");
const logger_1 = require("../utils/logger");
const proto_utils_1 = require("../utils/proto-utils");
let GrpcProtoService = class GrpcProtoService {
    constructor(options) {
        this.options = options;
        this.protoDefinition = null;
        this.isLoaded = false;
        this.loadingPromise = null;
        this.logger = new logger_1.GrpcLogger({
            ...(this.options?.logging ?? {}),
            context: 'ProtoLoader',
        });
        this.validateOptions();
    }
    validateOptions() {
        if (!this.options) {
            throw new Error('GRPC_OPTIONS is required');
        }
        if (!this.options.protoPath || typeof this.options.protoPath !== 'string') {
            throw new Error('protoPath is required and must be a string');
        }
        if (!this.options.package || typeof this.options.package !== 'string') {
            throw new Error('package is required and must be a string');
        }
        if (this.options.logging?.level === 'debug') {
            this.logger.debug(`ProtoLoader initialized with path: ${this.options.protoPath}, package: ${this.options.package}`);
        }
    }
    async onModuleInit() {
        try {
            this.logger.lifecycle('Loading proto files', {
                path: this.options.protoPath,
                package: this.options.package,
            });
            await this.load();
            this.logger.lifecycle('Proto files loaded successfully');
        }
        catch (error) {
            this.logger.error('Failed to load proto files', error);
            throw error;
        }
    }
    async load() {
        if (this.loadingPromise) {
            return this.loadingPromise;
        }
        if (this.isLoaded && this.protoDefinition) {
            return this.protoDefinition;
        }
        this.loadingPromise = this.performLoad();
        try {
            const result = await this.loadingPromise;
            this.isLoaded = true;
            if (this.options.logging?.level === 'debug') {
                const serviceNames = this.getLoadedServiceNames(result);
                this.logger.debug(`Loaded services: ${serviceNames.join(', ')}`);
            }
            return result;
        }
        catch (error) {
            this.loadingPromise = null;
            throw error;
        }
    }
    getLoadedServiceNames(definition) {
        const serviceNames = [];
        try {
            if (definition && typeof definition === 'object') {
                for (const [key, value] of Object.entries(definition)) {
                    if (typeof value === 'function') {
                        serviceNames.push(key);
                    }
                }
            }
        }
        catch {
        }
        return serviceNames;
    }
    async performLoad() {
        const { protoPath, package: packageName, loaderOptions } = this.options;
        try {
            this.validateProtoPath(protoPath);
            if (this.isDirectory(protoPath) || this.isGlobPattern(protoPath)) {
                return await this.loadMultipleProtoFiles(protoPath, packageName, loaderOptions);
            }
            else {
                return await this.loadSingleProtoFile(protoPath, packageName, loaderOptions);
            }
        }
        catch (error) {
            throw new Error(`Failed to load proto file(s): ${error.message}`);
        }
    }
    validateProtoPath(protoPath) {
        if (!protoPath.includes('*') && !this.isGlobPattern(protoPath)) {
            try {
                fs.accessSync(protoPath, fs.constants.R_OK);
            }
            catch {
                throw new Error(`Proto path is not accessible: ${protoPath}`);
            }
        }
    }
    async loadMultipleProtoFiles(protoPath, packageName, loaderOptions) {
        const protoFiles = await this.findProtoFiles(protoPath);
        if (protoFiles.length === 0) {
            throw new Error(`No proto files found in ${protoPath}`);
        }
        this.logger.lifecycle(`Found ${protoFiles.length} proto files`);
        const services = {};
        const errors = [];
        for (const file of protoFiles) {
            try {
                if (this.options.logging?.level === 'debug') {
                    this.logger.debug(`Loading proto file: ${file}`);
                }
                const packageDef = await (0, proto_utils_1.loadProto)(file, loaderOptions);
                const fileServices = this.getServiceByPackageName(packageDef, packageName);
                if (fileServices && typeof fileServices === 'object') {
                    Object.assign(services, fileServices);
                    this.logger.debug(`Loaded services from ${file}: ${Object.keys(fileServices).join(', ')}`);
                }
            }
            catch (error) {
                const errorMsg = `Error loading proto file ${file}: ${error.message}`;
                errors.push(errorMsg);
                if (this.options.logging?.logErrors !== false) {
                    this.logger.error(errorMsg, error);
                }
            }
        }
        if (Object.keys(services).length === 0) {
            throw new Error(`No services loaded successfully. Errors: ${errors.join('; ')}`);
        }
        this.logger.lifecycle('Proto files loaded successfully', {
            totalFiles: protoFiles.length,
            successfulFiles: protoFiles.length - errors.length,
            failedFiles: errors.length,
            totalServices: Object.keys(services).length,
        });
        this.protoDefinition = services;
        return services;
    }
    async loadSingleProtoFile(protoPath, packageName, loaderOptions) {
        try {
            const packageDefinition = await (0, proto_utils_1.loadProto)(protoPath, loaderOptions);
            const services = this.getServiceByPackageName(packageDefinition, packageName);
            if (!services || (typeof services === 'object' && Object.keys(services).length === 0)) {
                throw new Error(`No services found in package '${packageName}'`);
            }
            this.protoDefinition = services;
            return services;
        }
        catch (error) {
            throw new Error(`Failed to load proto file ${protoPath}: ${error.message}`);
        }
    }
    getProtoDefinition() {
        if (!this.isLoaded || !this.protoDefinition) {
            throw new Error('Proto files have not been loaded yet. Call load() first.');
        }
        return this.protoDefinition;
    }
    async loadService(serviceName) {
        try {
            this.validateServiceName(serviceName);
            const { protoPath, package: packageName, loaderOptions } = this.options;
            if (this.isDirectory(protoPath) || this.isGlobPattern(protoPath)) {
                return await this.loadServiceFromMultipleFiles(serviceName, protoPath, packageName, loaderOptions);
            }
            else {
                return await this.loadServiceFromSingleFile(serviceName, protoPath, packageName, loaderOptions);
            }
        }
        catch (error) {
            throw new Error(`Failed to load service ${serviceName}: ${error.message}`);
        }
    }
    validateServiceName(serviceName) {
        if (!serviceName || typeof serviceName !== 'string') {
            throw new Error('Service name is required and must be a string');
        }
        if (serviceName.trim().length === 0) {
            throw new Error('Service name cannot be empty');
        }
    }
    async loadServiceFromMultipleFiles(serviceName, protoPath, packageName, loaderOptions) {
        const protoFiles = await this.findProtoFiles(protoPath);
        if (protoFiles.length === 0) {
            throw new Error(`No proto files found in ${protoPath}`);
        }
        const errors = [];
        for (const file of protoFiles) {
            try {
                const packageDef = await (0, proto_utils_1.loadProto)(file, loaderOptions);
                const service = (0, proto_utils_1.getServiceByName)(packageDef, packageName, serviceName);
                if (service) {
                    return service;
                }
            }
            catch (error) {
                errors.push(`${file}: ${error.message}`);
            }
        }
        throw new Error(`Service ${serviceName} not found in any proto file. Errors: ${errors.join('; ')}`);
    }
    async loadServiceFromSingleFile(serviceName, protoPath, packageName, loaderOptions) {
        try {
            const packageDefinition = await (0, proto_utils_1.loadProto)(protoPath, loaderOptions);
            const service = (0, proto_utils_1.getServiceByName)(packageDefinition, packageName, serviceName);
            if (!service) {
                throw new Error(`Service ${serviceName} not found in package ${packageName}`);
            }
            return service;
        }
        catch (error) {
            throw new Error(`Failed to load service from ${protoPath}: ${error.message}`);
        }
    }
    isDirectory(filePath) {
        try {
            const stats = fs.statSync(filePath);
            return stats.isDirectory();
        }
        catch {
            return false;
        }
    }
    isGlobPattern(filePath) {
        return /[*?{}[\]!]/.test(filePath);
    }
    async findProtoFiles(pathPattern) {
        try {
            let pattern = pathPattern;
            if (this.isDirectory(pathPattern)) {
                pattern = path.join(pathPattern, '**', '*.proto');
            }
            const files = await (0, glob_1.glob)(pattern, {
                ignore: ['node_modules/**', '**/node_modules/**'],
                absolute: true,
                nodir: true,
            });
            const validFiles = [];
            for (const file of files) {
                try {
                    fs.accessSync(file, fs.constants.R_OK);
                    validFiles.push(file);
                }
                catch (error) {
                    if (this.options.logging?.logErrors !== false) {
                        this.logger.warn(`Cannot read proto file ${file}: ${error.message}`);
                    }
                }
            }
            return validFiles;
        }
        catch (error) {
            throw new Error(`Error finding proto files with pattern ${pathPattern}: ${error.message}`);
        }
    }
    getServiceByPackageName(proto, packageName) {
        try {
            if (!proto) {
                throw new Error('Proto definition is null or undefined');
            }
            if (!packageName) {
                return proto;
            }
            const parts = packageName.split('.');
            let current = proto;
            for (const part of parts) {
                if (!current || typeof current !== 'object') {
                    throw new Error(`Invalid package structure at '${part}'`);
                }
                if (!current[part]) {
                    throw new Error(`Package part '${part}' not found`);
                }
                current = current[part];
            }
            return current;
        }
        catch (error) {
            throw new Error(`Failed to find package ${packageName}: ${error.message}`);
        }
    }
};
exports.GrpcProtoService = GrpcProtoService;
exports.GrpcProtoService = GrpcProtoService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)(constants_1.GRPC_OPTIONS)),
    __metadata("design:paramtypes", [Object])
], GrpcProtoService);
//# sourceMappingURL=grpc-proto.service.js.map