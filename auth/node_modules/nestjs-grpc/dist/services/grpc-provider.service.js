"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcProviderService = void 0;
const grpc = __importStar(require("@grpc/grpc-js"));
const common_1 = require("@nestjs/common");
const constants_1 = require("../constants");
const logger_1 = require("../utils/logger");
const grpc_proto_service_1 = require("./grpc-proto.service");
let GrpcProviderService = class GrpcProviderService {
    constructor(options, protoService) {
        this.options = options;
        this.protoService = protoService;
        this.server = null;
        this.isRunning = false;
        this.controllerInstances = new Map();
        this.registeredServices = new Set();
        this.pendingControllers = new Map();
        this.logger = new logger_1.GrpcLogger({
            ...options.logging,
            context: 'GrpcProvider',
        });
    }
    async onModuleInit() {
        try {
            this.logger.lifecycle('Starting gRPC provider');
            this.createServer();
            await this.startServer();
            this.logger.lifecycle('gRPC provider started successfully', {
                url: this.options.url ?? 'localhost:50051',
                secure: this.options.secure ?? false,
                controllers: this.controllerInstances.size,
            });
        }
        catch (error) {
            this.logger.error('Failed to start gRPC provider', error);
            throw error;
        }
    }
    async onModuleDestroy() {
        try {
            this.logger.lifecycle('Shutting down gRPC provider');
            await this.stopServer();
            this.logger.lifecycle('gRPC provider shutdown complete');
        }
        catch (error) {
            this.logger.error('Error during gRPC provider shutdown', error);
        }
    }
    getServer() {
        return this.server;
    }
    isServerRunning() {
        return this.isRunning;
    }
    getControllerInstances() {
        return this.controllerInstances;
    }
    registerController(serviceName, instance, metadata) {
        try {
            this.controllerInstances.set(serviceName, instance);
            this.logger.debug(`Registered controller instance for service: ${serviceName}`);
            this.pendingControllers.set(serviceName, metadata);
            if (this.server && this.isRunning && !this.registeredServices.has(serviceName)) {
                this.addServiceToServer(serviceName, metadata);
                this.registeredServices.add(serviceName);
            }
            else if (!this.server || !this.isRunning) {
                this.logger.debug(`Server not ready, will register service ${serviceName} when server starts`);
            }
            else if (this.registeredServices.has(serviceName)) {
                this.logger.debug(`Service ${serviceName} already registered`);
            }
        }
        catch (error) {
            this.logger.error(`Failed to register controller ${serviceName}`, error);
            throw error;
        }
    }
    createServer() {
        this.server = new grpc.Server({
            'grpc.max_send_message_length': this.options.maxSendMessageSize,
            'grpc.max_receive_message_length': this.options.maxReceiveMessageSize,
        });
        this.logger.debug('gRPC server instance created');
    }
    async registerPendingControllers() {
        if (this.pendingControllers.size === 0) {
            this.logger.debug('No pending controllers to register');
            return;
        }
        this.logger.debug('Ensuring proto service is loaded before registering controllers');
        try {
            const loadPromise = this.protoService.load();
            const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('Proto service load timeout')), 30000));
            await Promise.race([loadPromise, timeoutPromise]);
            this.logger.debug('Proto service is ready');
        }
        catch (error) {
            this.logger.error('Failed to load proto service', error);
            return;
        }
        this.logger.debug(`Registering ${this.pendingControllers.size} pending controllers`);
        const registrationErrors = [];
        for (const [serviceName, metadata] of Array.from(this.pendingControllers.entries())) {
            if (!this.registeredServices.has(serviceName)) {
                try {
                    this.addServiceToServer(serviceName, metadata);
                    this.registeredServices.add(serviceName);
                    this.logger.debug(`Successfully registered pending controller: ${serviceName}`);
                }
                catch (error) {
                    const errorMsg = `Failed to register pending controller ${serviceName}: ${error.message}`;
                    registrationErrors.push(errorMsg);
                    this.logger.error(errorMsg, error);
                }
            }
        }
        if (registrationErrors.length > 0) {
            this.logger.warn(`Some controllers failed to register: ${registrationErrors.join(', ')}`);
        }
    }
    addServiceToServer(serviceName, metadata) {
        if (!this.server) {
            throw new Error('Server not initialized');
        }
        const protoDefinition = this.protoService.getProtoDefinition();
        this.logger.debug(`Looking for service definition: ${serviceName}`);
        const serviceDefinition = this.findServiceDefinition(protoDefinition, serviceName);
        if (!serviceDefinition) {
            this.logger.error(`Service definition not found for ${serviceName} in proto definition`);
            this.logger.debug(`Available services in proto: ${Object.keys(protoDefinition).join(', ')}`);
            throw new Error(`Service definition not found for ${serviceName}`);
        }
        this.logger.debug(`Service definition found for ${serviceName}`);
        this.logger.debug(`Validating methods for ${serviceName}`);
        this.validateMethods(serviceName, metadata, serviceDefinition);
    }
    createMethodHandler(serviceName, controllerMethodName) {
        return async (call, callback) => {
            const startTime = Date.now();
            try {
                this.logger.debug(`Method call: ${serviceName}.${controllerMethodName}`);
                const controllerInstance = this.controllerInstances.get(serviceName);
                if (!controllerInstance) {
                    throw new Error(`Controller instance not found for service ${serviceName}`);
                }
                const method = controllerInstance[controllerMethodName];
                if (!method || typeof method !== 'function') {
                    const availableMethods = Object.getOwnPropertyNames(Object.getPrototypeOf(controllerInstance));
                    this.logger.error(`Method not found. Available methods: ${availableMethods.join(', ')}`);
                    throw new Error(`Method ${controllerMethodName} not found in controller ${serviceName}`);
                }
                const request = call.request;
                const result = await method.call(controllerInstance, request);
                const duration = Date.now() - startTime;
                this.logger.performance(`${serviceName}.${controllerMethodName} completed`, duration);
                callback(null, result);
            }
            catch (error) {
                const duration = Date.now() - startTime;
                this.logger.error(`Method ${serviceName}.${controllerMethodName} failed after ${duration}ms`, error);
                const grpcError = this.convertToGrpcError(error);
                callback(grpcError);
            }
        };
    }
    findServiceDefinition(protoDefinition, serviceName) {
        this.logger.debug(`Finding service definition for: ${serviceName}`);
        if (!protoDefinition || typeof protoDefinition !== 'object') {
            this.logger.debug('Proto definition is null or not an object');
            return null;
        }
        this.logger.debug(`Looking for service ${serviceName} in proto definition`);
        this.logger.debug(`Available keys: ${Object.keys(protoDefinition).join(', ')}`);
        if (protoDefinition[serviceName]) {
            const service = protoDefinition[serviceName];
            this.logger.debug(`Found service ${serviceName} directly in proto definition`);
            if (typeof service === 'function') {
                this.logger.debug(`Service ${serviceName} is a function (constructor)`);
                return service;
            }
            if (service && typeof service === 'object' && service.service) {
                this.logger.debug(`Service ${serviceName} has service property`);
                return service;
            }
            this.logger.debug(`Service ${serviceName} found but is not a valid service definition`);
            return null;
        }
        this.logger.debug(`Service ${serviceName} not found directly in proto definition`);
        for (const key in protoDefinition) {
            const value = protoDefinition[key];
            if (value && typeof value === 'object' && value[serviceName]) {
                this.logger.debug(`Searching in nested package: ${key}`);
                const nestedService = value[serviceName];
                this.logger.debug(`Found service ${serviceName} in nested package ${key}`);
                return nestedService;
            }
        }
        this.logger.warn(`Service ${serviceName} not found in proto definition`);
        return null;
    }
    async startServer() {
        if (!this.server) {
            throw new Error('Server not created');
        }
        const url = this.options.url ?? 'localhost:50051';
        const credentials = this.createServerCredentials();
        return new Promise((resolve, reject) => {
            if (!this.server) {
                reject(new Error('Server not initialized'));
                return;
            }
            this.server.bindAsync(url, credentials, (error, port) => {
                if (error) {
                    reject(new Error(`Failed to bind server to ${url}: ${error.message}`));
                    return;
                }
                this.isRunning = true;
                this.registerPendingControllers()
                    .then(() => {
                    this.logger.lifecycle('gRPC server started', {
                        url,
                        port,
                        secure: this.options.secure,
                    });
                    resolve();
                })
                    .catch(registerError => {
                    this.logger.error('Failed to register pending controllers', registerError);
                    reject(registerError);
                });
            });
        });
    }
    createServerCredentials() {
        if (this.options.secure) {
            if (!this.options.privateKey || !this.options.certChain) {
                throw new Error('Private key and certificate chain are required for secure server');
            }
            return grpc.ServerCredentials.createSsl(this.options.rootCerts ?? null, [
                {
                    private_key: this.options.privateKey,
                    cert_chain: this.options.certChain,
                },
            ], false);
        }
        return grpc.ServerCredentials.createInsecure();
    }
    async stopServer() {
        if (!this.server || !this.isRunning) {
            return;
        }
        return new Promise(resolve => {
            if (!this.server) {
                resolve();
                return;
            }
            this.server.tryShutdown(error => {
                if (error) {
                    this.logger.error('Error during graceful shutdown, forcing shutdown', error);
                    if (this.server) {
                        this.server.forceShutdown();
                    }
                }
                this.isRunning = false;
                this.server = null;
                this.controllerInstances.clear();
                this.registeredServices.clear();
                resolve();
            });
        });
    }
    convertToGrpcError(error) {
        if (error.code !== undefined && error.message) {
            return error;
        }
        return {
            code: grpc.status.INTERNAL,
            message: error.message ?? 'Internal server error',
            details: error.details ?? 'An unexpected error occurred',
        };
    }
    validateMethods(serviceName, metadata, serviceDefinition) {
        this.logger.debug(`Validating methods for service: ${serviceName}`);
        const protoMethods = this.extractProtoMethods(serviceDefinition, serviceName);
        const registeredMethods = Array.from(metadata.methods.keys());
        this.logger.debug(`Proto methods found: ${protoMethods.join(', ')}`);
        this.logger.debug(`Registered methods: ${registeredMethods.join(', ')}`);
        const methodImplementations = {};
        for (const [methodName, methodMetadata] of metadata.methods) {
            if (protoMethods.includes(methodName)) {
                const originalMethodName = methodMetadata?.originalMethodName ??
                    methodName.charAt(0).toLowerCase() + methodName.slice(1);
                methodImplementations[methodName] = this.createMethodHandler(serviceName, originalMethodName);
                this.logger.debug(`Method ${methodName} mapped to ${originalMethodName}`);
            }
            else {
                this.logger.warn(`Method ${methodName} not found in proto definition. Available: ${protoMethods.join(', ')}`);
            }
        }
        if (Object.keys(methodImplementations).length === 0) {
            this.logger.warn(`No valid methods found for service ${serviceName}, skipping registration`);
            return;
        }
        try {
            if (!this.server) {
                throw new Error('Server not initialized');
            }
            if (typeof serviceDefinition === 'function' && serviceDefinition.service) {
                this.server.addService(serviceDefinition.service, methodImplementations);
            }
            else {
                this.server.addService(serviceDefinition, methodImplementations);
            }
            this.logger.debug(`Successfully registered service: ${serviceName} with ${Object.keys(methodImplementations).length} methods`);
        }
        catch (error) {
            this.logger.error(`Failed to register service ${serviceName}:`, error);
            throw error;
        }
    }
    extractProtoMethods(serviceDefinition, serviceName) {
        this.logger.debug(`Extracting proto methods for service: ${serviceName}`);
        const methods = [];
        if (!serviceDefinition) {
            this.logger.debug('Service definition is null/undefined');
            return methods;
        }
        if (serviceDefinition.service && typeof serviceDefinition.service === 'object') {
            const service = serviceDefinition.service;
            if (service.originalName && typeof service.originalName === 'object') {
                const originalMethods = Object.keys(service.originalName);
                this.logger.debug(`Found methods in service.originalName: ${originalMethods.join(', ')}`);
                methods.push(...originalMethods);
            }
            if (service.methods && typeof service.methods === 'object') {
                const methodKeys = Object.keys(service.methods);
                this.logger.debug(`Found methods in service.methods: ${methodKeys.join(', ')}`);
                methods.push(...methodKeys);
            }
            if (service.methodsMap && typeof service.methodsMap === 'object') {
                const mapKeys = Object.keys(service.methodsMap);
                this.logger.debug(`Found methods in service.methodsMap: ${mapKeys.join(', ')}`);
                methods.push(...mapKeys);
            }
            if (service.methods && Array.isArray(service.methods)) {
                const arrayMethods = service.methods
                    .map((method) => method.name ?? method.originalName)
                    .filter(Boolean);
                this.logger.debug(`Found methods in service.methods array: ${arrayMethods.join(', ')}`);
                methods.push(...arrayMethods);
            }
            const serviceKeys = Object.keys(service);
            const methodKeys = serviceKeys.filter(key => key !== 'originalName' &&
                key !== 'methods' &&
                key !== 'methodsMap' &&
                typeof service[key] === 'object');
            if (methodKeys.length > 0) {
                this.logger.debug(`Found methods as direct keys in service: ${methodKeys.join(', ')}`);
                methods.push(...methodKeys);
            }
        }
        if (typeof serviceDefinition === 'function') {
            const functionProps = Object.getOwnPropertyNames(serviceDefinition);
            const methodProps = functionProps.filter(prop => prop !== 'service' &&
                prop !== 'constructor' &&
                prop !== 'prototype' &&
                prop !== 'length' &&
                prop !== 'name' &&
                typeof serviceDefinition[prop] === 'object');
            if (methodProps.length > 0) {
                this.logger.debug(`Found methods in function properties: ${methodProps.join(', ')}`);
                methods.push(...methodProps);
            }
        }
        if (typeof serviceDefinition === 'object') {
            const objectProps = Object.keys(serviceDefinition).filter(key => key !== 'service' &&
                key !== 'constructor' &&
                key !== 'prototype' &&
                typeof serviceDefinition[key] === 'object');
            if (objectProps.length > 0) {
                this.logger.debug(`Found methods in object properties: ${objectProps.join(', ')}`);
                methods.push(...objectProps);
            }
        }
        if (typeof serviceDefinition === 'function' && serviceDefinition.service) {
            const service = serviceDefinition.service;
            if (service.originalName) {
                const originalMethods = Object.keys(service.originalName);
                this.logger.debug(`Found methods in service.originalName: ${originalMethods.join(', ')}`);
                methods.push(...originalMethods);
            }
        }
        const uniqueMethods = [...new Set(methods)].filter(method => method &&
            typeof method === 'string' &&
            method.trim().length > 0 &&
            method !== 'prototype');
        this.logger.debug(`Extracted methods for ${serviceName}: ${uniqueMethods.join(', ')}`);
        return uniqueMethods;
    }
};
exports.GrpcProviderService = GrpcProviderService;
exports.GrpcProviderService = GrpcProviderService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)(constants_1.GRPC_OPTIONS)),
    __metadata("design:paramtypes", [Object, grpc_proto_service_1.GrpcProtoService])
], GrpcProviderService);
//# sourceMappingURL=grpc-provider.service.js.map