#!/usr/bin/env node
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanup = cleanup;
exports.run = run;
exports.initializeCli = initializeCli;
const fs_1 = require("fs");
const path_1 = require("path");
const process_1 = __importDefault(require("process"));
const commander_1 = require("commander");
const commands_1 = require("../commands");
const logger_1 = require("../utils/logger");
const logger = new logger_1.GrpcLogger({
    context: 'CLI',
    level: 'log',
});
function getPackageVersion() {
    const packagePath = (0, path_1.join)(__dirname, '..', '..', 'package.json');
    const packageContent = (0, fs_1.readFileSync)(packagePath, 'utf8');
    const packageJson = JSON.parse(packageContent);
    return packageJson.version;
}
function validateArgs(argv = process_1.default.argv) {
    const args = argv.slice(2);
    if (args.includes('--help') ||
        args.includes('-h') ||
        args.includes('--version') ||
        args.includes('-V')) {
        return true;
    }
    if (args.length === 0) {
        return true;
    }
    if (!['generate'].includes(args[0])) {
        return false;
    }
    return true;
}
let eventListeners = [];
function setupErrorHandling() {
    const uncaughtHandler = (error) => {
        logger.error('Fatal error', error);
        process_1.default.exit(1);
    };
    const rejectionHandler = (reason) => {
        logger.error('Unhandled promise rejection', reason instanceof Error ? reason : String(reason));
        process_1.default.exit(1);
    };
    const sigtermHandler = () => {
        logger.lifecycle('Received SIGTERM, shutting down gracefully');
        process_1.default.exit(0);
    };
    const sigintHandler = () => {
        logger.lifecycle('Received SIGINT, shutting down gracefully');
        process_1.default.exit(0);
    };
    process_1.default.on('uncaughtException', uncaughtHandler);
    process_1.default.on('unhandledRejection', rejectionHandler);
    process_1.default.on('SIGTERM', sigtermHandler);
    process_1.default.on('SIGINT', sigintHandler);
    eventListeners = [
        { event: 'uncaughtException', handler: uncaughtHandler },
        { event: 'unhandledRejection', handler: rejectionHandler },
        { event: 'SIGTERM', handler: sigtermHandler },
        { event: 'SIGINT', handler: sigintHandler },
    ];
}
function cleanup() {
    eventListeners.forEach(({ event, handler }) => {
        process_1.default.removeListener(event, handler);
    });
    eventListeners = [];
}
function initializeCli() {
    setupErrorHandling();
    if (!validateArgs()) {
        logger.error('Error: Invalid arguments provided');
        process_1.default.exit(1);
    }
    const program = new commander_1.Command();
    const version = getPackageVersion();
    logger.lifecycle('Initializing CLI', { version });
    program.name('nestjs-grpc').description('CLI tool for NestJS gRPC package').version(version);
    program
        .command('generate')
        .description('Generate TypeScript definitions from protobuf files')
        .option('-p, --proto <pattern>', 'Path to proto file, directory, or glob pattern', './protos/**/*.proto')
        .option('-o, --output <dir>', 'Output directory for generated files', './src/generated')
        .option('-w, --watch', 'Watch mode for file changes', false)
        .option('-c, --classes', 'Generate classes instead of interfaces', false)
        .option('--no-comments', 'Disable comments in generated files')
        .option('--no-client-interfaces', 'Do not generate client interfaces')
        .option('-f, --package-filter <package>', 'Filter by package name')
        .option('-r, --recursive', 'Recursively search directories for .proto files', true)
        .option('-v, --verbose', 'Enable verbose logging')
        .option('-s, --silent', 'Disable all logging except errors')
        .action(async (options) => {
        try {
            logger.lifecycle('Starting generate command', {
                proto: options.proto,
                output: options.output,
            });
            await (0, commands_1.generateCommand)(options);
            logger.lifecycle('Generate command completed successfully');
            process_1.default.exit(0);
        }
        catch (error) {
            logger.error('Command failed', error instanceof Error ? error : String(error));
            process_1.default.exit(1);
        }
    });
    program.on('command:*', () => {
        logger.error('Error: Invalid arguments provided');
        process_1.default.exit(1);
    });
    try {
        program.parse(process_1.default.argv);
        if (!process_1.default.argv.slice(2).length) {
            program.outputHelp();
        }
    }
    catch (error) {
        logger.error('Error parsing arguments', error instanceof Error ? error : String(error));
        process_1.default.exit(1);
    }
}
function run(argv = process_1.default.argv) {
    setupErrorHandling();
    if (!validateArgs(argv)) {
        logger.error('Error: Invalid arguments provided');
        process_1.default.exit(1);
    }
    const program = new commander_1.Command();
    const version = getPackageVersion();
    logger.lifecycle('Initializing CLI', { version });
    program.name('nestjs-grpc').description('CLI tool for NestJS gRPC package').version(version);
    program
        .command('generate')
        .description('Generate TypeScript definitions from protobuf files')
        .option('-p, --proto <pattern>', 'Path to proto file, directory, or glob pattern', './protos/**/*.proto')
        .option('-o, --output <dir>', 'Output directory for generated files', './src/generated')
        .option('-w, --watch', 'Watch mode for file changes', false)
        .option('-c, --classes', 'Generate classes instead of interfaces', false)
        .option('--no-comments', 'Disable comments in generated files')
        .option('--no-client-interfaces', 'Do not generate client interfaces')
        .option('-f, --package-filter <package>', 'Filter by package name')
        .option('-r, --recursive', 'Recursively search directories for .proto files', true)
        .option('-v, --verbose', 'Enable verbose logging')
        .option('-s, --silent', 'Disable all logging except errors')
        .action(async (options) => {
        try {
            logger.lifecycle('Starting generate command', {
                proto: options.proto,
                output: options.output,
            });
            await (0, commands_1.generateCommand)(options);
            logger.lifecycle('Generate command completed successfully');
            process_1.default.exit(0);
        }
        catch (error) {
            logger.error('Command failed', error instanceof Error ? error : String(error));
            process_1.default.exit(1);
        }
    });
    program.on('command:*', () => {
        logger.error('Error: Invalid arguments provided');
        process_1.default.exit(1);
    });
    try {
        program.parse(argv);
        if (!argv.slice(2).length) {
            program.outputHelp();
            process_1.default.exit(0);
        }
    }
    catch (error) {
        if (error instanceof Error &&
            (error.message.includes('help') ||
                error.message.includes('version') ||
                argv.includes('--help') ||
                argv.includes('-h') ||
                argv.includes('--version') ||
                argv.includes('-V'))) {
            process_1.default.exit(0);
        }
        else {
            logger.error('Error parsing arguments', error instanceof Error ? error : String(error));
            process_1.default.exit(1);
        }
    }
}
if (require.main === module) {
    initializeCli();
}
//# sourceMappingURL=cli.js.map