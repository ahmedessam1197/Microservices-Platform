"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TYPE_MAPPING = void 0;
exports.snakeToCamel = snakeToCamel;
exports.pascalToCamel = pascalToCamel;
exports.formatFieldName = formatFieldName;
exports.formatMethodName = formatMethodName;
exports.mapProtoTypeToTs = mapProtoTypeToTs;
exports.getEnumDefinition = getEnumDefinition;
exports.getMessageDefinition = getMessageDefinition;
exports.getServiceClientDefinition = getServiceClientDefinition;
exports.getServiceInterfaceDefinition = getServiceInterfaceDefinition;
exports.generateTypeDefinitions = generateTypeDefinitions;
exports.TYPE_MAPPING = {
    double: 'number',
    float: 'number',
    int32: 'number',
    int64: 'string',
    uint32: 'number',
    uint64: 'string',
    sint32: 'number',
    sint64: 'string',
    fixed32: 'number',
    fixed64: 'string',
    sfixed32: 'number',
    sfixed64: 'string',
    bool: 'boolean',
    string: 'string',
    bytes: 'Uint8Array',
};
function snakeToCamel(str) {
    return str.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase());
}
function pascalToCamel(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
}
function formatFieldName(fieldName) {
    return snakeToCamel(fieldName);
}
function formatMethodName(methodName) {
    const camelCase = snakeToCamel(methodName);
    return pascalToCamel(camelCase);
}
function mapProtoTypeToTs(type, isRepeated = false) {
    const mappedType = exports.TYPE_MAPPING[type] || type;
    return isRepeated ? `${mappedType}[]` : mappedType;
}
function getEnumDefinition(enumType, options) {
    let definition = '';
    if (options?.includeComments && enumType.comment) {
        definition += `/**\n * ${enumType.comment.replace(/\n/g, '\n * ')}\n */\n`;
    }
    definition += `export enum ${enumType.name} {\n`;
    Object.entries(enumType.values).forEach(([key, value]) => {
        const formattedKey = formatFieldName(key);
        definition += `  ${formattedKey} = ${value},\n`;
    });
    definition += '}\n';
    return definition;
}
function getMessageDefinition(messageType, options) {
    let definition = '';
    if (options?.includeComments && messageType.comment) {
        definition += `/**\n * ${messageType.comment.replace(/\n/g, '\n * ')}\n */\n`;
    }
    if (options?.useClasses) {
        definition += `export class ${messageType.name} {\n`;
    }
    else {
        definition += `export interface ${messageType.name} {\n`;
    }
    messageType.fieldsArray.forEach(field => {
        if (options?.includeComments && field.comment) {
            definition += `  /**\n   * ${field.comment.replace(/\n/g, '\n   * ')}\n   */\n`;
        }
        const fieldName = formatFieldName(field.name);
        const isRepeated = field.repeated || field.rule === 'repeated';
        const fieldType = mapProtoTypeToTs(field.type, isRepeated);
        const isOptional = !field.required;
        if (options?.includeComments && fieldName !== field.name) {
            definition += `  /** Original proto field: ${field.name} */\n`;
        }
        definition += `  ${fieldName}${isOptional ? '?' : ''}: ${fieldType};\n`;
    });
    definition += '}\n';
    return definition;
}
function getServiceClientDefinition(serviceType, options) {
    let definition = '';
    if (options?.includeComments && serviceType.comment) {
        definition += `/**\n * ${serviceType.comment.replace(/\n/g, '\n * ')}\n */\n`;
    }
    definition += `export interface ${serviceType.name}Client {\n`;
    serviceType.methodsArray.forEach(method => {
        if (options?.includeComments && method.comment) {
            definition += `  /**\n   * ${method.comment.replace(/\n/g, '\n   * ')}\n   */\n`;
        }
        const methodName = formatMethodName(method.name);
        const inputType = method.requestType;
        const outputType = method.responseType;
        if (options?.includeComments &&
            methodName !== method.name.charAt(0).toLowerCase() + method.name.slice(1)) {
            definition += `  /** Original proto method: ${method.name} */\n`;
        }
        if (method.responseStream) {
            definition += `  ${methodName}(request: ${inputType}, metadata?: GrpcMetadata): Observable<${outputType}>;\n`;
        }
        else {
            definition += `  ${methodName}(request: ${inputType}, metadata?: GrpcMetadata): Observable<${outputType}>;\n`;
        }
    });
    definition += '}\n';
    return definition;
}
function getServiceInterfaceDefinition(serviceType, options) {
    let definition = '';
    if (options?.includeComments && serviceType.comment) {
        definition += `/**\n * Controller interface for ${serviceType.name} service\n */\n`;
    }
    definition += `export interface ${serviceType.name}Interface {\n`;
    serviceType.methodsArray.forEach(method => {
        if (options?.includeComments && method.comment) {
            definition += `  /**\n   * ${method.comment.replace(/\n/g, '\n   * ')}\n   */\n`;
        }
        const methodName = formatMethodName(method.name);
        const inputType = method.requestType;
        const outputType = method.responseType;
        if (options?.includeComments &&
            methodName !== method.name.charAt(0).toLowerCase() + method.name.slice(1)) {
            definition += `  /** Original proto method: ${method.name} */\n`;
        }
        if (method.responseStream) {
            definition += `  ${methodName}(request: ${inputType}): Observable<${outputType}>;\n`;
        }
        else {
            definition += `  ${methodName}(request: ${inputType}): Promise<${outputType}> | Observable<${outputType}>;\n`;
        }
    });
    definition += '}\n';
    return definition;
}
function generateTypeDefinitions(root, options) {
    let typeDefinitions = '// This file is auto-generated by nestjs-grpc\n';
    typeDefinitions += '// Field names have been converted from snake_case to camelCase\n\n';
    typeDefinitions += "import { Observable } from 'rxjs';\n\n";
    typeDefinitions +=
        'export type GrpcMetadata = Record<string, string | string[] | Buffer | Buffer[]>;\n\n';
    function processNamespace(namespace, prefix = '') {
        namespace.nestedArray.forEach(nested => {
            const fullName = prefix ? `${prefix}.${nested.name}` : nested.name;
            if (options?.packageFilter && !fullName.startsWith(options.packageFilter)) {
                return;
            }
            if (nested.constructor?.name === 'Type') {
                typeDefinitions += `${getMessageDefinition(nested, options)}\n`;
                if (nested.nestedArray) {
                    processNamespace(nested, fullName);
                }
            }
            else if (nested.constructor?.name === 'Service') {
                if (options?.includeClientInterfaces !== false) {
                    typeDefinitions += `${getServiceClientDefinition(nested, options)}\n`;
                }
                typeDefinitions += `${getServiceInterfaceDefinition(nested, options)}\n`;
            }
            else if (nested.constructor?.name === 'Enum') {
                typeDefinitions += `${getEnumDefinition(nested, options)}\n`;
            }
            else if (nested.constructor?.name === 'Namespace') {
                if (nested.nestedArray) {
                    processNamespace(nested, fullName);
                }
            }
        });
    }
    processNamespace(root);
    return typeDefinitions;
}
//# sourceMappingURL=type-utils.js.map