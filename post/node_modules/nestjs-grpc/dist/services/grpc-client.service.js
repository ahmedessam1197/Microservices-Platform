"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcClientService = void 0;
const grpc = __importStar(require("@grpc/grpc-js"));
const common_1 = require("@nestjs/common");
const rxjs_1 = require("rxjs");
const operators_1 = require("rxjs/operators");
const constants_1 = require("../constants");
const logger_1 = require("../utils/logger");
const grpc_proto_service_1 = require("./grpc-proto.service");
let GrpcClientService = class GrpcClientService {
    constructor(options, protoService) {
        this.options = options;
        this.protoService = protoService;
        this.clients = new Map();
        this.activeStreams = new Set();
        this.CLIENT_CACHE_TTL = 5 * 60 * 1000;
        this.CLEANUP_INTERVAL = 60 * 1000;
        if (!options) {
            throw new Error('GRPC_OPTIONS is required');
        }
        if (!options.protoPath || typeof options.protoPath !== 'string') {
            throw new Error('protoPath is required in gRPC options');
        }
        if (!options.package || typeof options.package !== 'string') {
            throw new Error('package is required in gRPC options');
        }
        this.logger = new logger_1.GrpcLogger({
            ...options.logging,
            context: 'GrpcClient',
        });
    }
    onModuleInit() {
        if (!this.protoService) {
            throw new Error('GrpcProtoService is not available');
        }
        try {
            this.logger.lifecycle('GrpcClientService starting', {
                maxCacheSize: this.CLIENT_CACHE_TTL,
                cleanupInterval: this.CLEANUP_INTERVAL,
            });
            void this.protoService.load();
            this.cleanupInterval = setInterval(() => {
                this.cleanupStaleClients();
            }, this.CLEANUP_INTERVAL);
            this.logger.lifecycle('GrpcClientService started successfully');
        }
        catch (_error) {
            throw new Error('Failed to initialize GrpcClientService');
        }
    }
    onModuleDestroy() {
        try {
            this.logger.lifecycle('GrpcClientService shutting down');
            if (this.cleanupInterval) {
                clearInterval(this.cleanupInterval);
            }
            let streamsClosedCount = 0;
            for (const stream of this.activeStreams) {
                try {
                    if (stream && typeof stream.cancel === 'function') {
                        stream.cancel();
                        streamsClosedCount++;
                    }
                }
                catch (error) {
                    this.logger.warn('Error cancelling stream', error);
                }
            }
            this.activeStreams.clear();
            let clientsClosedCount = 0;
            for (const [key, cachedClient] of this.clients) {
                try {
                    if (cachedClient.client && typeof cachedClient.client.close === 'function') {
                        cachedClient.client.close();
                        clientsClosedCount++;
                    }
                }
                catch (error) {
                    this.logger.warn(`Error closing client ${key}`, error);
                }
            }
            this.clients.clear();
            this.logger.lifecycle('GrpcClientService shutdown complete', {
                clientsClosed: clientsClosedCount,
                streamsClosed: streamsClosedCount,
            });
        }
        catch (error) {
            this.logger.error('Error during GrpcClientService cleanup', error);
        }
    }
    async create(serviceName, options) {
        if (!serviceName || typeof serviceName !== 'string') {
            throw new Error('Service name is required and must be a string');
        }
        if (options !== undefined && (typeof options !== 'object' || options === null)) {
            throw new Error('Options must be an object');
        }
        if (options?.url !== undefined && typeof options.url !== 'string') {
            throw new Error('URL option must be a string');
        }
        try {
            this.logger.debug(`Creating gRPC client for service: ${serviceName}`);
            const clientOptions = this.mergeClientOptions(serviceName, options);
            const clientKey = this.getClientKey(serviceName, clientOptions);
            const cachedClient = this.clients.get(clientKey);
            if (cachedClient) {
                cachedClient.lastUsed = Date.now();
                this.logger.debug(`Returning cached gRPC client for ${serviceName}`);
                return cachedClient.client;
            }
            const serviceConstructor = await this.getServiceConstructor(serviceName);
            const client = this.createClient(serviceConstructor, clientOptions);
            this.clients.set(clientKey, {
                client,
                createdAt: Date.now(),
                lastUsed: Date.now(),
                config: this.getConfigHash(clientOptions),
            });
            this.logger.connection('Created gRPC client', serviceName, {
                url: clientOptions.url,
                secure: clientOptions.secure,
            });
            return client;
        }
        catch (error) {
            if (error.message.includes('not found in proto definition') ||
                error.message.includes('Proto load failed') ||
                error.message.includes('not loaded yet') ||
                error.message.includes('Proto not loaded')) {
                throw new Error('Service lookup failed');
            }
            throw error;
        }
    }
    async call(serviceName, methodName, request, options) {
        this.logger.debug(`Starting call to ${serviceName}.${methodName}`);
        const clientOptions = this.mergeClientOptions(serviceName, options);
        if (!this.validateMethod(serviceName, methodName)) {
            this.logger.error(`Method validation failed for ${serviceName}.${methodName}`);
            throw new Error(`Method ${methodName} not found in service ${serviceName}`);
        }
        this.logger.debug(`Method validation passed for ${serviceName}.${methodName}`);
        const client = await this.create(serviceName, clientOptions);
        const startTime = Date.now();
        try {
            this.logger.debug(`Making unary call to ${serviceName}.${methodName}`);
            const result = await this.executeWithRetry(() => this.callUnaryMethod(client, methodName, request, clientOptions), clientOptions?.maxRetries ?? constants_1.DEFAULT_RETRY_ATTEMPTS, clientOptions?.retryDelay ?? constants_1.DEFAULT_RETRY_DELAY);
            const duration = Date.now() - startTime;
            this.logger.performance(`${serviceName}.${methodName} completed`, duration);
            return result;
        }
        catch (error) {
            const duration = Date.now() - startTime;
            this.logger.error(`Unary call ${serviceName}.${methodName} failed after ${duration}ms`, error);
            throw error;
        }
    }
    serverStream(serviceName, methodName, request, options) {
        const startTime = Date.now();
        return new rxjs_1.Observable(observer => {
            this.create(serviceName, options)
                .then(client => {
                try {
                    this.logger.methodCall(methodName, serviceName);
                    const stream = client[methodName](request);
                    this.activeStreams.add(stream);
                    const subscription = (0, rxjs_1.fromEvent)(stream, 'data')
                        .pipe((0, operators_1.map)((data) => {
                        this.logger.debug(`Received stream data from ${serviceName}.${methodName}`);
                        return data;
                    }), (0, operators_1.catchError)(error => {
                        const duration = Date.now() - startTime;
                        this.logger.error(`Server stream ${serviceName}.${methodName} failed after ${duration}ms`, error);
                        this.activeStreams.delete(stream);
                        return (0, rxjs_1.throwError)(() => error);
                    }))
                        .subscribe(observer);
                    stream.on('end', () => {
                        const duration = Date.now() - startTime;
                        this.logger.performance(`Server stream ${serviceName}.${methodName} completed`, duration);
                        this.activeStreams.delete(stream);
                        subscription.unsubscribe();
                        observer.complete();
                    });
                    stream.on('error', (error) => {
                        const duration = Date.now() - startTime;
                        this.logger.error(`Server stream ${serviceName}.${methodName} failed after ${duration}ms`, error);
                        this.activeStreams.delete(stream);
                        subscription.unsubscribe();
                        observer.error(error);
                    });
                }
                catch (error) {
                    const duration = Date.now() - startTime;
                    this.logger.error(`Server stream ${serviceName}.${methodName} failed after ${duration}ms`, error);
                    observer.error(error);
                }
            })
                .catch(error => {
                const duration = Date.now() - startTime;
                this.logger.error(`Server stream ${serviceName}.${methodName} client creation failed after ${duration}ms`, error);
                observer.error(error);
            });
        });
    }
    async clientStream(serviceName, methodName, request, options) {
        const startTime = Date.now();
        const client = await this.create(serviceName, options);
        try {
            this.logger.debug(`Calling client stream method: ${serviceName}.${methodName}`);
            const stream = client[methodName]();
            this.activeStreams.add(stream);
            request.subscribe({
                next: (data) => {
                    stream.write(data);
                },
                error: error => {
                    this.logger.error(`Client stream ${serviceName}.${methodName} request error`, error);
                    stream.end();
                    this.activeStreams.delete(stream);
                },
                complete: () => {
                    stream.end();
                },
            });
            const result = await new Promise((resolve, reject) => {
                stream.on('data', (data) => {
                    resolve(data);
                });
                stream.on('error', error => {
                    const duration = Date.now() - startTime;
                    this.logger.error(`Client stream ${serviceName}.${methodName} failed after ${duration}ms`, error);
                    this.activeStreams.delete(stream);
                    reject(error);
                });
                stream.on('end', () => {
                    const duration = Date.now() - startTime;
                    this.logger.performance(`Client stream ${serviceName}.${methodName} completed`, duration);
                    this.activeStreams.delete(stream);
                });
            });
            return result;
        }
        catch (error) {
            const duration = Date.now() - startTime;
            this.logger.error(`Client stream ${serviceName}.${methodName} failed after ${duration}ms`, error);
            throw error;
        }
    }
    bidiStream(serviceName, methodName, request, options) {
        const startTime = Date.now();
        return new rxjs_1.Observable(observer => {
            this.create(serviceName, options)
                .then(client => {
                try {
                    this.logger.debug(`Calling bidirectional stream method: ${serviceName}.${methodName}`);
                    const stream = client[methodName]();
                    this.activeStreams.add(stream);
                    request.subscribe({
                        next: (data) => {
                            stream.write(data);
                        },
                        error: error => {
                            this.logger.error(`Bidirectional stream ${serviceName}.${methodName} request error`, error);
                            stream.end();
                            this.activeStreams.delete(stream);
                            observer.error(error);
                        },
                        complete: () => {
                            stream.end();
                        },
                    });
                    const subscription = (0, rxjs_1.fromEvent)(stream, 'data')
                        .pipe((0, operators_1.map)((data) => {
                        this.logger.debug(`Received bidirectional stream data from ${serviceName}.${methodName}`);
                        return data;
                    }), (0, operators_1.catchError)(error => {
                        const duration = Date.now() - startTime;
                        this.logger.error(`Bidirectional stream ${serviceName}.${methodName} failed after ${duration}ms`, error);
                        this.activeStreams.delete(stream);
                        return (0, rxjs_1.throwError)(() => error);
                    }))
                        .subscribe(observer);
                    stream.on('end', () => {
                        const duration = Date.now() - startTime;
                        this.logger.performance(`Bidirectional stream ${serviceName}.${methodName} completed`, duration);
                        this.activeStreams.delete(stream);
                        subscription.unsubscribe();
                        observer.complete();
                    });
                    stream.on('error', (error) => {
                        const duration = Date.now() - startTime;
                        this.logger.error(`Bidirectional stream ${serviceName}.${methodName} failed after ${duration}ms`, error);
                        this.activeStreams.delete(stream);
                        subscription.unsubscribe();
                        observer.error(error);
                    });
                }
                catch (error) {
                    const duration = Date.now() - startTime;
                    this.logger.error(`Bidirectional stream ${serviceName}.${methodName} failed after ${duration}ms`, error);
                    observer.error(error);
                }
            })
                .catch(error => {
                const duration = Date.now() - startTime;
                this.logger.error(`Bidirectional stream ${serviceName}.${methodName} client creation failed after ${duration}ms`, error);
                observer.error(error);
            });
        });
    }
    cleanupStaleClients() {
        const now = Date.now();
        const staleCutoff = now - this.CLIENT_CACHE_TTL;
        let cleanedUpCount = 0;
        for (const [key, cachedClient] of this.clients) {
            if (cachedClient.lastUsed < staleCutoff) {
                try {
                    if (cachedClient.client && typeof cachedClient.client.close === 'function') {
                        cachedClient.client.close();
                    }
                    cleanedUpCount++;
                }
                catch (error) {
                    this.logger.warn(`Error closing stale client ${key}`, error);
                }
                finally {
                    this.clients.delete(key);
                }
            }
        }
        if (cleanedUpCount > 0) {
            this.logger.debug(`Cleaned up ${cleanedUpCount} stale gRPC clients`);
        }
    }
    async executeWithRetry(fn, maxRetries, retryDelay) {
        let lastError = new Error('Unknown error');
        for (let attempt = 0; attempt <= maxRetries; attempt++) {
            try {
                return await fn();
            }
            catch (error) {
                lastError = error;
                if (attempt === maxRetries) {
                    break;
                }
                this.logger.debug(`Retry attempt ${attempt + 1}/${maxRetries} failed, retrying in ${retryDelay}ms`);
                await new Promise(resolve => setTimeout(resolve, retryDelay));
            }
        }
        throw lastError;
    }
    getClientKey(serviceName, options) {
        return `${serviceName}:${options.url}:${options.secure ? 'secure' : 'insecure'}`;
    }
    getConfigHash(options) {
        return JSON.stringify({
            url: options.url,
            secure: options.secure,
            timeout: options.timeout,
            maxRetries: options.maxRetries,
            retryDelay: options.retryDelay,
        });
    }
    mergeClientOptions(serviceName, options) {
        const timeout = options?.timeout ?? constants_1.DEFAULT_TIMEOUT;
        const maxRetries = options?.maxRetries ?? constants_1.DEFAULT_RETRY_ATTEMPTS;
        const retryDelay = options?.retryDelay ?? constants_1.DEFAULT_RETRY_DELAY;
        return {
            service: serviceName,
            package: options?.package ?? this.options.package,
            url: options?.url ?? this.options.url ?? 'localhost:50051',
            secure: options?.secure ?? this.options.secure ?? false,
            timeout: Math.max(Math.min(timeout, constants_1.VALIDATION_LIMITS.MAX_TIMEOUT), constants_1.VALIDATION_LIMITS.MIN_TIMEOUT),
            maxRetries: Math.max(Math.min(maxRetries, constants_1.VALIDATION_LIMITS.MAX_RETRIES), constants_1.VALIDATION_LIMITS.MIN_RETRIES),
            retryDelay: Math.max(Math.min(retryDelay, constants_1.VALIDATION_LIMITS.MAX_RETRY_DELAY), constants_1.VALIDATION_LIMITS.MIN_RETRY_DELAY),
            rootCerts: options?.rootCerts ?? this.options.rootCerts,
            privateKey: options?.privateKey ?? this.options.privateKey,
            certChain: options?.certChain ?? this.options.certChain,
            channelOptions: options?.channelOptions,
        };
    }
    async getServiceConstructor(serviceName) {
        try {
            await this.protoService.load();
            const packageDefinition = this.protoService.getProtoDefinition();
            if (!packageDefinition) {
                throw new Error('gRPC services not loaded yet');
            }
            const servicePath = this.findServicePath(packageDefinition, serviceName);
            if (!servicePath) {
                const availableServices = this.getAvailableServiceNames(packageDefinition);
                this.logger.debug(`Available services: ${availableServices.join(', ')}`);
                throw new Error(`Service '${serviceName}' not found in proto definition. Available services: ${availableServices.join(', ')}`);
            }
            if (typeof servicePath !== 'function') {
                throw new Error(`'${serviceName}' is not a valid constructor function`);
            }
            return servicePath;
        }
        catch (error) {
            if (error.message.includes('not loaded yet') ||
                error.message.includes('Proto not loaded')) {
                throw new Error(`Service lookup failed: ${error.message}`);
            }
            throw error;
        }
    }
    getAvailableServiceNames(obj) {
        const serviceNames = [];
        if (!obj || typeof obj !== 'object') {
            return serviceNames;
        }
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                if (typeof value === 'function') {
                    serviceNames.push(key);
                }
                else if (typeof value === 'object') {
                    serviceNames.push(...this.getAvailableServiceNames(value));
                }
            }
        }
        return serviceNames;
    }
    findServicePath(obj, serviceName) {
        if (!obj || typeof obj !== 'object') {
            return null;
        }
        if (obj[serviceName] && typeof obj[serviceName] === 'function') {
            return obj[serviceName];
        }
        for (const key in obj) {
            if (obj.hasOwnProperty(key) && typeof obj[key] === 'object') {
                const result = this.findServicePath(obj[key], serviceName);
                if (result) {
                    return result;
                }
            }
        }
        return null;
    }
    createClient(serviceConstructor, options) {
        try {
            const credentials = options.secure
                ? grpc.credentials.createSsl(options.rootCerts, options.privateKey, options.certChain)
                : grpc.credentials.createInsecure();
            const client = new serviceConstructor(options.url, credentials, {
                'grpc.keepalive_time_ms': 2 * 60 * 60 * 1000,
                'grpc.keepalive_timeout_ms': 20 * 1000,
                'grpc.keepalive_permit_without_calls': true,
                'grpc.max_send_message_length': this.options.maxSendMessageSize,
                'grpc.max_receive_message_length': this.options.maxReceiveMessageSize,
                ...options.channelOptions,
            });
            return client;
        }
        catch (error) {
            throw new Error(`Failed to create gRPC client for service ${options.service}: ${error.message}`);
        }
    }
    callUnaryMethod(client, methodName, request, options) {
        return new Promise((resolve, reject) => {
            const deadline = options?.timeout ? new Date(Date.now() + options.timeout) : undefined;
            const callOptions = deadline ? { deadline } : {};
            client[methodName](request, callOptions, (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(response);
                }
            });
        });
    }
    validateMethod(serviceName, methodName) {
        try {
            const protoDefinition = this.protoService.getProtoDefinition();
            if (!protoDefinition) {
                this.logger.warn('Proto definition not loaded');
                return false;
            }
            const service = protoDefinition[serviceName];
            if (!service) {
                this.logger.warn(`Service ${serviceName} not found in proto definition`);
                return false;
            }
            return true;
        }
        catch (error) {
            this.logger.error(`Failed to validate method ${serviceName}.${methodName}`, error);
            return false;
        }
    }
};
exports.GrpcClientService = GrpcClientService;
exports.GrpcClientService = GrpcClientService = __decorate([
    (0, common_1.Injectable)(),
    __param(0, (0, common_1.Inject)(constants_1.GRPC_OPTIONS)),
    __metadata("design:paramtypes", [Object, grpc_proto_service_1.GrpcProtoService])
], GrpcClientService);
//# sourceMappingURL=grpc-client.service.js.map