"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcControllerDiscoveryService = void 0;
const common_1 = require("@nestjs/common");
const core_1 = require("@nestjs/core");
const constants_1 = require("../constants");
const logger_1 = require("../utils/logger");
const grpc_registry_service_1 = require("./grpc-registry.service");
let GrpcControllerDiscoveryService = class GrpcControllerDiscoveryService {
    constructor(discoveryService, metadataScanner, reflector, registryService) {
        this.discoveryService = discoveryService;
        this.metadataScanner = metadataScanner;
        this.reflector = reflector;
        this.registryService = registryService;
        this.logger = new logger_1.GrpcLogger({ context: 'GrpcControllerDiscovery' });
    }
    onModuleInit() {
        this.logger.lifecycle('Starting gRPC controller discovery');
        this.discoverAndRegisterControllers();
    }
    discoverAndRegisterControllers() {
        this.logger.debug('Discovering gRPC controllers');
        const controllers = this.discoveryService.getControllers();
        this.logger.debug(`Found ${controllers.length} controllers to check`);
        for (const controllerWrapper of controllers) {
            const controller = controllerWrapper.instance ?? controllerWrapper;
            const controllerName = controller.constructor.name;
            this.logger.debug(`Checking controller: ${controllerName}`);
            const grpcMetadata = this.reflector.get(constants_1.GRPC_CONTROLLER_METADATA, controller.constructor);
            if (!grpcMetadata) {
                this.logger.debug(`Skipping regular HTTP controller: ${controllerName}`);
                continue;
            }
            const isProvider = this.reflector.get('__isProvider__', controller.constructor);
            if (isProvider) {
                this.logger.debug(`Skipping non-controller provider: ${controllerName}`);
                continue;
            }
            this.logger.debug(`Found gRPC controller: ${controllerName}`);
            try {
                this.registerController(controller, grpcMetadata);
            }
            catch (error) {
                this.logger.error(`Failed to register controller ${controllerName}`, error);
            }
        }
    }
    registerController(instance, controllerMetadata) {
        try {
            const serviceName = controllerMetadata.serviceName;
            if (!serviceName) {
                this.logger.warn('Controller missing service name, skipping registration');
                return;
            }
            this.logger.debug(`Discovering methods for controller: ${serviceName}`);
            const methods = new Map();
            const prototype = Object.getPrototypeOf(instance);
            const methodNames = Object.getOwnPropertyNames(prototype).filter(name => name !== 'constructor' && typeof prototype[name] === 'function');
            this.logger.debug(`Method names to check: ${methodNames.join(', ')}`);
            for (const methodName of methodNames) {
                this.logger.debug(`Checking method: ${methodName}`);
                try {
                    let methodMetadata = this.reflector.get(constants_1.GRPC_METHOD_METADATA, prototype[methodName]);
                    if (methodMetadata) {
                        const grpcMethodName = methodMetadata.methodName ?? methodName;
                        methods.set(grpcMethodName, methodMetadata);
                        this.logger.debug(`Found gRPC method: ${serviceName}.${grpcMethodName}`);
                        continue;
                    }
                    methodMetadata = Reflect.getMetadata(constants_1.GRPC_METHOD_METADATA, prototype, methodName);
                    if (methodMetadata) {
                        const grpcMethodName = methodMetadata.methodName ?? methodName;
                        methods.set(grpcMethodName, methodMetadata);
                        this.logger.debug(`Found gRPC method (alt): ${serviceName}.${grpcMethodName}`);
                        continue;
                    }
                    const inferredMethodName = methodName.charAt(0).toUpperCase() + methodName.slice(1);
                    methods.set(inferredMethodName, {
                        methodName: inferredMethodName,
                        originalMethodName: methodName,
                    });
                    this.logger.debug(`Inferred gRPC method: ${serviceName}.${inferredMethodName} from ${methodName}`);
                }
                catch (error) {
                    this.logger.debug(`Error checking method ${methodName}: ${error.message}`);
                }
            }
            if (methods.size === 0) {
                this.logger.warn(`No gRPC methods found for controller: ${serviceName}`);
                return;
            }
            const methodList = Array.from(methods.keys());
            this.logger.lifecycle(`Discovered methods for ${serviceName}:`, {
                methods: methodList,
                count: methods.size,
            });
            const metadata = {
                serviceName,
                package: controllerMetadata.package ?? 'default',
                methods,
            };
            this.registryService.registerController(serviceName, instance, metadata);
            this.logger.lifecycle(`Successfully registered gRPC controller: ${serviceName}`, {
                methods: methods.size,
                methodNames: methodList,
            });
        }
        catch (error) {
            this.logger.error(`Failed to register controller`, error);
            throw error;
        }
    }
};
exports.GrpcControllerDiscoveryService = GrpcControllerDiscoveryService;
exports.GrpcControllerDiscoveryService = GrpcControllerDiscoveryService = __decorate([
    (0, common_1.Injectable)(),
    __metadata("design:paramtypes", [core_1.DiscoveryService,
        core_1.MetadataScanner,
        core_1.Reflector,
        grpc_registry_service_1.GrpcRegistryService])
], GrpcControllerDiscoveryService);
//# sourceMappingURL=grpc-controller-discovery.service.js.map