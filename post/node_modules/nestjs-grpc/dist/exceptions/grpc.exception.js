"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GrpcException = exports.GrpcConsumerErrorHandler = exports.GrpcConsumerException = exports.RETRYABLE_STATUS_CODES = void 0;
exports.getGrpcStatusDescription = getGrpcStatusDescription;
exports.httpStatusToGrpcStatus = httpStatusToGrpcStatus;
const grpc_js_1 = require("@grpc/grpc-js");
const common_1 = require("@nestjs/common");
const microservices_1 = require("@nestjs/microservices");
const constants_1 = require("../constants");
const logger_1 = require("../utils/logger");
exports.RETRYABLE_STATUS_CODES = [
    constants_1.GrpcErrorCode.UNAVAILABLE,
    constants_1.GrpcErrorCode.DEADLINE_EXCEEDED,
    constants_1.GrpcErrorCode.RESOURCE_EXHAUSTED,
    constants_1.GrpcErrorCode.ABORTED,
    constants_1.GrpcErrorCode.INTERNAL,
];
function getGrpcStatusDescription(code) {
    switch (code) {
        case constants_1.GrpcErrorCode.OK:
            return 'Success';
        case constants_1.GrpcErrorCode.CANCELLED:
            return 'Operation was cancelled';
        case constants_1.GrpcErrorCode.UNKNOWN:
            return 'Unknown error';
        case constants_1.GrpcErrorCode.INVALID_ARGUMENT:
            return 'Invalid argument provided';
        case constants_1.GrpcErrorCode.DEADLINE_EXCEEDED:
            return 'Request timeout exceeded';
        case constants_1.GrpcErrorCode.NOT_FOUND:
            return 'Resource not found';
        case constants_1.GrpcErrorCode.ALREADY_EXISTS:
            return 'Resource already exists';
        case constants_1.GrpcErrorCode.PERMISSION_DENIED:
            return 'Permission denied';
        case constants_1.GrpcErrorCode.RESOURCE_EXHAUSTED:
            return 'Resource exhausted';
        case constants_1.GrpcErrorCode.FAILED_PRECONDITION:
            return 'Failed precondition';
        case constants_1.GrpcErrorCode.ABORTED:
            return 'Operation aborted';
        case constants_1.GrpcErrorCode.OUT_OF_RANGE:
            return 'Value out of range';
        case constants_1.GrpcErrorCode.UNIMPLEMENTED:
            return 'Method not implemented';
        case constants_1.GrpcErrorCode.INTERNAL:
            return 'Internal server error';
        case constants_1.GrpcErrorCode.UNAVAILABLE:
            return 'Service unavailable';
        case constants_1.GrpcErrorCode.DATA_LOSS:
            return 'Data loss';
        case constants_1.GrpcErrorCode.UNAUTHENTICATED:
            return 'Authentication required';
        default:
            return `Unknown status code: ${code}`;
    }
}
function httpStatusToGrpcStatus(httpStatus) {
    switch (httpStatus) {
        case 200:
            return constants_1.GrpcErrorCode.OK;
        case 400:
            return constants_1.GrpcErrorCode.INVALID_ARGUMENT;
        case 401:
            return constants_1.GrpcErrorCode.UNAUTHENTICATED;
        case 403:
            return constants_1.GrpcErrorCode.PERMISSION_DENIED;
        case 404:
            return constants_1.GrpcErrorCode.NOT_FOUND;
        case 409:
            return constants_1.GrpcErrorCode.ALREADY_EXISTS;
        case 412:
            return constants_1.GrpcErrorCode.FAILED_PRECONDITION;
        case 416:
            return constants_1.GrpcErrorCode.OUT_OF_RANGE;
        case 429:
            return constants_1.GrpcErrorCode.RESOURCE_EXHAUSTED;
        case 499:
            return constants_1.GrpcErrorCode.CANCELLED;
        case 500:
            return constants_1.GrpcErrorCode.INTERNAL;
        case 501:
            return constants_1.GrpcErrorCode.UNIMPLEMENTED;
        case 503:
            return constants_1.GrpcErrorCode.UNAVAILABLE;
        case 504:
            return constants_1.GrpcErrorCode.DEADLINE_EXCEEDED;
        default:
            return constants_1.GrpcErrorCode.UNKNOWN;
    }
}
class GrpcConsumerException extends Error {
    constructor(error) {
        super(error.message);
        this.error = error;
        this.name = 'GrpcConsumerException';
    }
    isRetryable() {
        return exports.RETRYABLE_STATUS_CODES.includes(this.error.code);
    }
    getCode() {
        return this.error.code;
    }
    getDetails() {
        return this.error.details;
    }
    getMetadata() {
        return this.error.metadata;
    }
    getServiceName() {
        return this.error.serviceName;
    }
    getMethodName() {
        return this.error.methodName;
    }
    getDuration() {
        return this.error.duration;
    }
    getTimestamp() {
        return this.error.timestamp;
    }
}
exports.GrpcConsumerException = GrpcConsumerException;
let GrpcConsumerErrorHandler = class GrpcConsumerErrorHandler {
    constructor() {
        this.logger = new logger_1.GrpcLogger({ context: 'GrpcConsumerErrorHandler' });
    }
    handleError(error, serviceName, methodName, startTime) {
        const duration = Date.now() - startTime;
        const timestamp = new Date();
        const grpcError = this.extractGrpcError(error);
        const consumerError = {
            code: grpcError.code,
            message: grpcError.message,
            serviceName,
            methodName,
            details: grpcError.details,
            metadata: grpcError.metadata,
            timestamp,
            duration,
        };
        this.logError(consumerError, error);
        return new GrpcConsumerException(consumerError);
    }
    extractGrpcError(error) {
        if (error && typeof error.code === 'number') {
            return {
                code: error.code,
                message: error.message ?? error.details ?? 'gRPC error',
                details: error.details,
                metadata: error.metadata,
            };
        }
        if (error instanceof Error) {
            return {
                code: constants_1.GrpcErrorCode.INTERNAL,
                message: error.message || 'Internal error',
                details: error.stack,
            };
        }
        if (typeof error === 'string') {
            return {
                code: constants_1.GrpcErrorCode.UNKNOWN,
                message: error,
            };
        }
        return {
            code: constants_1.GrpcErrorCode.UNKNOWN,
            message: 'Unknown error occurred',
            details: error,
        };
    }
    logError(consumerError, originalError) {
        const _logData = {
            service: consumerError.serviceName,
            method: consumerError.methodName,
            code: consumerError.code,
            duration: `${consumerError.duration}ms`,
            timestamp: consumerError.timestamp.toISOString(),
        };
        if (consumerError.code === constants_1.GrpcErrorCode.CANCELLED) {
            this.logger.debug(`gRPC call cancelled: ${consumerError.serviceName}.${consumerError.methodName}`);
        }
        else if (exports.RETRYABLE_STATUS_CODES.includes(consumerError.code)) {
            this.logger.warn(`gRPC call failed (retryable): ${consumerError.message}`);
        }
        else {
            this.logger.error(`gRPC call failed: ${consumerError.message}`, originalError);
        }
    }
    isRetryableError(error) {
        const grpcError = this.extractGrpcError(error);
        return exports.RETRYABLE_STATUS_CODES.includes(grpcError.code);
    }
};
exports.GrpcConsumerErrorHandler = GrpcConsumerErrorHandler;
exports.GrpcConsumerErrorHandler = GrpcConsumerErrorHandler = __decorate([
    (0, common_1.Injectable)()
], GrpcConsumerErrorHandler);
class GrpcException extends microservices_1.RpcException {
    constructor(options) {
        const opts = GrpcException.normalizeOptions(options);
        super(opts.message);
        this.code = opts.code;
        this.details = opts.details ?? null;
        this.metadata = GrpcException.validateMetadata(opts.metadata ?? {});
        Object.defineProperty(this, 'name', { value: 'GrpcException' });
    }
    static normalizeOptions(options) {
        if (typeof options === 'string') {
            if (!options.trim()) {
                throw new Error('Error message cannot be empty');
            }
            return {
                code: constants_1.GrpcErrorCode.UNKNOWN,
                message: options.trim(),
            };
        }
        if (!options || typeof options !== 'object') {
            throw new Error('Options must be an object or string');
        }
        if (!options.message || typeof options.message !== 'string') {
            throw new Error('Message is required and must be a string');
        }
        if (options.message.trim().length === 0) {
            throw new Error('Message cannot be empty');
        }
        if (!Object.values(constants_1.GrpcErrorCode).includes(options.code)) {
            throw new Error(`Invalid gRPC error code: ${options.code}`);
        }
        return {
            code: options.code,
            message: options.message.trim(),
            details: options.details,
            metadata: options.metadata,
        };
    }
    static validateMetadata(metadata) {
        if (typeof metadata !== 'object' || Array.isArray(metadata)) {
            throw new Error('Metadata must be an object');
        }
        const validatedMetadata = {};
        for (const [key, value] of Object.entries(metadata)) {
            if (!key || typeof key !== 'string') {
                throw new Error('Metadata keys must be non-empty strings');
            }
            if (value === null || value === undefined) {
                continue;
            }
            if (typeof value === 'string' || Buffer.isBuffer(value)) {
                validatedMetadata[key] = value;
            }
            else if (Array.isArray(value)) {
                const stringArray = value.filter((item) => typeof item === 'string');
                const bufferArray = value.filter((item) => Buffer.isBuffer(item));
                if (stringArray.length > 0) {
                    validatedMetadata[key] = stringArray;
                }
                else if (bufferArray.length > 0) {
                    validatedMetadata[key] = bufferArray;
                }
            }
        }
        return validatedMetadata;
    }
    getCode() {
        return this.code;
    }
    getDetails() {
        return this.details;
    }
    getMetadata() {
        return { ...this.metadata };
    }
    toMetadata() {
        const metadata = new grpc_js_1.Metadata();
        try {
            Object.entries(this.metadata).forEach(([key, value]) => {
                if (Array.isArray(value)) {
                    value.forEach(v => {
                        if (v !== null && v !== undefined) {
                            metadata.add(key, v);
                        }
                    });
                }
                else {
                    metadata.add(key, value);
                }
            });
        }
        catch (_error) {
            return new grpc_js_1.Metadata();
        }
        return metadata;
    }
    getError() {
        return {
            code: this.code,
            message: this.message,
            details: this.details,
            metadata: this.metadata,
        };
    }
    static ok(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.OK, message, details, metadata });
    }
    static cancelled(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.CANCELLED, message, details, metadata });
    }
    static unknown(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.UNKNOWN, message, details, metadata });
    }
    static invalidArgument(message, details, metadata) {
        return new GrpcException({
            code: constants_1.GrpcErrorCode.INVALID_ARGUMENT,
            message,
            details,
            metadata,
        });
    }
    static deadlineExceeded(message, details, metadata) {
        return new GrpcException({
            code: constants_1.GrpcErrorCode.DEADLINE_EXCEEDED,
            message,
            details,
            metadata,
        });
    }
    static notFound(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.NOT_FOUND, message, details, metadata });
    }
    static alreadyExists(message, details, metadata) {
        return new GrpcException({
            code: constants_1.GrpcErrorCode.ALREADY_EXISTS,
            message,
            details,
            metadata,
        });
    }
    static permissionDenied(message, details, metadata) {
        return new GrpcException({
            code: constants_1.GrpcErrorCode.PERMISSION_DENIED,
            message,
            details,
            metadata,
        });
    }
    static resourceExhausted(message, details, metadata) {
        return new GrpcException({
            code: constants_1.GrpcErrorCode.RESOURCE_EXHAUSTED,
            message,
            details,
            metadata,
        });
    }
    static failedPrecondition(message, details, metadata) {
        return new GrpcException({
            code: constants_1.GrpcErrorCode.FAILED_PRECONDITION,
            message,
            details,
            metadata,
        });
    }
    static aborted(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.ABORTED, message, details, metadata });
    }
    static outOfRange(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.OUT_OF_RANGE, message, details, metadata });
    }
    static unimplemented(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.UNIMPLEMENTED, message, details, metadata });
    }
    static internal(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.INTERNAL, message, details, metadata });
    }
    static unavailable(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.UNAVAILABLE, message, details, metadata });
    }
    static dataLoss(message, details, metadata) {
        return new GrpcException({ code: constants_1.GrpcErrorCode.DATA_LOSS, message, details, metadata });
    }
    static unauthenticated(message, details, metadata) {
        return new GrpcException({
            code: constants_1.GrpcErrorCode.UNAUTHENTICATED,
            message,
            details,
            metadata,
        });
    }
}
exports.GrpcException = GrpcException;
//# sourceMappingURL=grpc.exception.js.map